/**
 * @file CglAdvCut.hpp
 * @brief File containing CglAdvCut class and related methods
 * @author A. M. Kazachkov
 * @date 2019-11-14
 */
#pragma once

#include <vector>
#include <string>

// COIN-OR files
#include <CglCutGenerator.hpp>

// Project files
#include "Parameters.hpp"
#include "TimeStats.hpp"

#include "CglVPC.hpp"

/**********************************************************************************************************
 * CglAdvCut Class, implemented as a CglCutGenerator
 **********************************************************************************************************/
class CglAdvCut : public CglCutGenerator {
public:
  ///@{
  /// @name Enums
  /// If adding to any of these enums, do not forget to add the appropriate name (in the right position) in *Name in the source file

  /// @brief Documenting the exit status after / whether cuts are generated
  enum class ExitReason {
    SUCCESS_EXIT = 0,
    CUT_LIMIT_EXIT,
    FAIL_LIMIT_EXIT,
    TIME_LIMIT_EXIT,
    NO_CUTS_LIKELY_EXIT,
    UNKNOWN,
    NUM_EXIT_REASONS
  }; /* ExitReason */

  /// @brief Timing
  enum class CutTimeStats {
    TOTAL_TIME,
    INIT_SOLVE_TIME,
    GEN_CUTS_TIME,
    NUM_TIME_STATS
  }; /* CutTimeStats */

  /// @brief Type of cuts generated
  enum class CutType {
    ONE_SIDED_CUT,
    OPTIMALITY_CUT,
    OTHER_CUT,
    NUM_CUT_TYPES
  }; /* CutType */

  /// @brief Types of objectives used to generate the cuts
  enum class ObjectiveType {
    DUMMY_OBJ,
    ONE_SIDED,
    OTHER,
    NUM_OBJECTIVE_TYPES
  }; /* ObjectiveType */

  /// @brief Types of failures that occurred during cut generation
  enum class FailureType {
    ABANDONED,
    BAD_DYNAMISM,
    BAD_SUPPORT,
    BAD_VIOLATION,
    CUT_LIMIT,
    DUAL_INFEASIBLE,
    DUPLICATE_SIC,
    DUPLICATE_OTHER,
    ITERATION_LIMIT,
    ORTHOGONALITY_SIC,
    ORTHOGONALITY_OTHER,
    PRIMAL_INFEASIBLE,
    TIME_LIMIT,
    NUMERICAL_ISSUES_WARNING,
    DLB_EQUALS_DUB_NO_OBJ,
    DLB_EQUALS_LPOPT_NO_OBJ,
    PRIMAL_INFEASIBLE_NO_OBJ,
    NUMERICAL_ISSUES_NO_OBJ,
    UNKNOWN,
    NUM_FAILURE_TYPES
  }; /* FailureType */
  ///@}

  ///@{
  /// @name Static variables/functions
  static const std::vector<std::string> ExitReasonName;
  static const std::vector<std::string> CutTimeStatsName;
  static const std::vector<std::string> CutTypeName;
  static const std::vector<std::string> ObjectiveTypeName;
  static const std::vector<std::string> FailureTypeName;
  static int getCutLimit(const int CUTLIMIT, const int numFracVar);
  ///@}

  ///@{
  /// @name Class variables
  CglVPC gen;
  StrengtheningParameters::Parameters params;
  CglAdvCut::ExitReason exitReason;
  TimeStats timer;

  std::vector<CutType> cutType; // one entry per cut
  std::vector<ObjectiveType> objType; // one entry per cut

  std::vector<int> numCutsOfType;
  std::vector<int> numCutsFromHeur, numObjFromHeur, numFailsFromHeur;
  std::vector<int> numFails;

  int init_num_cuts; // useful for keeping track of # of old cuts when isSetupForRepeatedUse == true
  int num_cuts; // this is always the number of cuts generated by the current call to generateCuts
  int num_obj_tried, num_failures;
  ///@} // class variables

  // When setup for repeated use, information about previous cuts is not deleted
  // This is useful, e.g., when generating cuts from multiple split disjunctions
  // (the user does not want to regenerate cuts from previous splits,
  // and, moreover, would want to replace old dominated cuts from different splits)
  bool isSetupForRepeatedUse; // default is false
  // It can be the case that the instance is setup for repeated use, but we do not wish to replace any given cuts (merely prevent duplicating them)
  // On the other hand, if the instance is not setup for repeated use, we require that canReplaceGivenCuts is false
  // (Though the user can still give a set of old cuts to prevent duplicating them)
  bool canReplaceGivenCuts; // default is false

  /** Default constructor */
  CglAdvCut();

  /** Param constructor */
  CglAdvCut(const StrengtheningParameters::Parameters& param);

  /** Copy constructor */
  CglAdvCut(const CglAdvCut& source);

  /** Destructor */
  ~CglAdvCut();

  /** Assignment operator */
  CglAdvCut& operator=(const CglAdvCut& source);

  /** Clone */
  virtual CglCutGenerator* clone() const;

  /** Set params based on Parameters */
  void setParams(const StrengtheningParameters::Parameters& param);

  /**
   * Prepare for repeated use (e.g., multiple disjunctions in one round)
   * When setup for repeated use, information about previous cuts is not deleted
   * This is useful, e.g., when generating cuts from multiple split disjunctions
   * (the user does not want to regenerate cuts from previous splits,
   * and, moreover, would want to replace old dominated cuts from different splits)
   */
  inline void setupRepeatedUse(bool useRepeatedly = true) {
    isSetupForRepeatedUse = useRepeatedly;
  }

  /** Get the cut limit for this generator */
  int getCutLimit() const;

  /** Other get/set methods */

  /** generateCuts */
  virtual void generateCuts(const OsiSolverInterface&, OsiCuts&, const CglTreeInfo = CglTreeInfo());

  /** Any time a cut is added, it should go through this method */
  void addCut(const OsiRowCut& cut, OsiCuts& cuts, const CutType& type, const ObjectiveType& cutHeur);

  /** Print methods */
  inline void printCutsOfType(FILE* logfile = stdout) const {
    for (int i = 0; i < static_cast<int>(CutType::NUM_CUT_TYPES); i++) {
      fprintf(logfile, "%s,", CutTypeName[i].c_str());
      fprintf(logfile, "%d,", numCutsOfType[i]);
      fprintf(logfile, "\n");
    }
    fflush(logfile);
  } /* printCutsOfType */
  inline void printObjFromHeur(FILE* logfile = stdout) const {
      for (int i = 0; i < static_cast<int>(ObjectiveType::NUM_OBJECTIVE_TYPES); i++) {
        fprintf(logfile, "OBJ_%s,", ObjectiveTypeName[i].c_str());
        fprintf(logfile, "%d,", numObjFromHeur[i]);
        fprintf(logfile, "\n");
      }
      fflush(logfile);
    } /* printObjFromHeur */
  inline void printCutsFromHeur(FILE* logfile = stdout) const {
      for (int i = 0; i < static_cast<int>(ObjectiveType::NUM_OBJECTIVE_TYPES); i++) {
        fprintf(logfile, "CUTS_%s,", ObjectiveTypeName[i].c_str());
        fprintf(logfile, "%d,", numCutsFromHeur[i]);
        fprintf(logfile, "\n");
      }
      fflush(logfile);
    } /* printCutsFromHeur */
  inline void printFailsFromHeur(FILE* logfile = stdout) const {
    for (int i = 0; i < static_cast<int>(ObjectiveType::NUM_OBJECTIVE_TYPES); i++) {
      fprintf(logfile, "FAILS_%s,", ObjectiveTypeName[i].c_str());
      fprintf(logfile, "%d,", numFailsFromHeur[i]);
      fprintf(logfile, "\n");
    }
    fflush(logfile);
  } /* printFailsFromHeur */
  inline void printFailures(FILE* logfile = stdout) const {
    for (int i = 0; i < static_cast<int>(FailureType::NUM_FAILURE_TYPES); i++) {
      fprintf(logfile, "%s,", FailureTypeName[i].c_str());
      fprintf(logfile, "%d,", numFails[i]);
      fprintf(logfile, "\n");
    }
    fflush(logfile);
  } /* printFailures */

protected:
  /// For storing data about a problem and optimal basis
  struct ProblemData {
    int num_cols;
    double lp_opt;
    double minAbsCoeff, maxAbsCoeff; // useful for dynamism calculation
    double EPS;
    std::vector<int> NBVarIndex, varBasicInRow;
    std::vector<int> rowOfVar; // row in which var is basic; if var is nonbasic, then it is (-(1 + nonbasic index))
    std::vector<int> rowOfOrigNBVar; // row in which "original" nonbasic vars are basic; if var is still nonbasic, then it is (-(1 + new nonbasic index))
    std::vector<double> NBReducedCost;

    /** Get index of variable in NBVarIndex, and -1 if it is basic */
    int getVarNBIndex(const int var) const {
      if (rowOfVar[var] <= -1) {
        return -1 * (1 + rowOfVar[var]);
      } else {
        return -1;
      }
    }
  } probData;

  /** Clear old information before another round of cuts */
  void setupAsNew();

  /** Initialize everything */
  void initialize(const CglAdvCut* const source = NULL, const StrengtheningParameters::Parameters* const param = NULL);

  void getProblemData(OsiSolverInterface* const solver, ProblemData& probData,
      const ProblemData* const origProbData = NULL,
      const bool enable_factorization = true);

  inline bool reachedCutLimit() const {
    const bool reached_limit = (num_cuts >= getCutLimit()); 
    return reached_limit;
  } /* reachedCutLimit */
  inline bool reachedTimeLimit(const CutTimeStats& timeName, const double max_time) const {
    return reachedTimeLimit(CutTimeStatsName[static_cast<int>(timeName)], max_time);
  } /* reachedTimeLimit */
  inline bool reachedTimeLimit(const std::string& timeName, const double max_time) const {
    const bool reached_limit = (timer.get_total_time(timeName) > max_time);
    return reached_limit;
  } /* reachedTimeLimit */
//  inline bool reachedTimelimit(const std::chrono::time_point<std::chrono::high_resolution_clock>& start_chrono) const {
//    std::chrono::duration<double> elapsed_seconds = std::chrono::high_resolution_clock::now() - start_chrono;
//    const bool reached_limit = (elapsed_seconds.count() > this->param.get(TIMELIMIT));
////    if (reached_limit)
////      exitReason = CglAdvCut::ExitReason::TIME_LIMIT_EXIT;
//    return reached_limit;
//  }
  bool reachedFailureLimit(const int num_cuts, const int num_fails,
      const double few_cuts_fail_threshold = 0.95,
      const double many_cuts_fail_threshold = 0.90,
      const double many_obj_fail_threshold = 0.80,
      const double time_fail_threshold = 0.66) const;

  inline void finish(CglAdvCut::ExitReason exitReason = CglAdvCut::ExitReason::UNKNOWN) {
    this->exitReason = exitReason;
    this->timer.end_timer(CutTimeStatsName[static_cast<int>(CutTimeStats::TOTAL_TIME)]);
#ifdef TRACE
    printf("CglAdvCut: Finishing with exit reason: %s. Number cuts: %d.\n", ExitReasonName[static_cast<int>(exitReason)].c_str(), num_cuts);
#endif
  } /* finish */
}; /* CglAdvCut */
